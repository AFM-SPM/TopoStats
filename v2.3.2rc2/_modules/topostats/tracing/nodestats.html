
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>topostats.tracing.nodestats &#8212; TopoStats 2.3.3.dev27+g279473507 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=2b4ec01c" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../../_static/documentation_options.js?v=766c09a3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const defaultStyle = document.createElement('style');
defaultStyle.textContent = `pre.mermaid {
    /* Same as .mermaid-container > pre */
    display: block;
    width: 100%;
}

pre.mermaid > svg {
    /* Same as .mermaid-container > pre > svg */
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}
`;
document.head.appendChild(defaultStyle);

const fullscreenStyle = document.createElement('style');
fullscreenStyle.textContent = `.mermaid-container {
    display: flex;
    flex-direction: row;
    width: 100%;
}

.mermaid-container > pre {
    display: block;
    width: 100%;
}

.mermaid-container > pre > svg {
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}

.mermaid-fullscreen-btn {
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 95vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-container-fullscreen pre.mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen .mermaid svg {
    height: 100% !important;
    width: 100% !important;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}`;
document.head.appendChild(fullscreenStyle);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if ("False" === "True") {
        const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
        if(mermaids_to_add_zoom > 0) {
            var svgs = d3.selectAll("");
            if(all_mermaids.length !== mermaids_processed.length) {
                setTimeout(load, 200);
                return;
            } else if(svgs.size() !== mermaids_to_add_zoom) {
                setTimeout(load, 200);
                return;
            } else {
                svgs.each(function() {
                    var svg = d3.select(this);
                    svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                    var inner = svg.select("g");
                    var zoom = d3.zoom().on("zoom", function(event) {
                        inner.attr("transform", event.transform);
                    });
                    svg.call(zoom);
                });
            }
        }
    } else if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(load, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    // Stop here if not adding fullscreen capability
    if ("True" !== "True") return;

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-container-fullscreen${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-container-fullscreen');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.sdisplay = 'block';

                if ("False" === "True") {
                    setTimeout(() => {
                        const g = svg.querySelector('g');
                        if (g) {
                            var svgD3 = d3.select(svg);
                            svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                            var inner = svgD3.select("g");
                            var zoom = d3.zoom().on("zoom", function(event) {
                                inner.attr("transform", event.transform);
                            });
                            svgD3.call(zoom);
                        }
                    }, 100);
                }
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/topostats/tracing/nodestats';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="2.3" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">TopoStats 2.3.3.dev27+g279473507 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../introduction.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../configuration.html">
    Configuration
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing.html">
    Contributing
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../notebooks.html">
    Notebooks
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../advanced.html">
    Advanced Documentation
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../workflow.html">
    Workflow
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../data_dictionary.html">
    Data Dictionary
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../related_software.html">
    Related Software
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../glossary.html">
    Glossary
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../faq.html">
    Frequently Asked Questions
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../autoapi/index.html">
    API Reference
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../introduction.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../installation.html">
    Installation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../configuration.html">
    Configuration
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing.html">
    Contributing
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notebooks.html">
    Notebooks
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../advanced.html">
    Advanced Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../workflow.html">
    Workflow
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../data_dictionary.html">
    Data Dictionary
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../related_software.html">
    Related Software
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../glossary.html">
    Glossary
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../faq.html">
    Frequently Asked Questions
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../autoapi/index.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<h3>Versions</h3>
<ul>
  <li><a href="../../../../v2.0.0/index.html">v2.0.0</a></li>
  <li><a href="../../../../v2.1.0/index.html">v2.1.0</a></li>
  <li><a href="../../../../v2.1.1/index.html">v2.1.1</a></li>
  <li><a href="../../../../v2.1.2/index.html">v2.1.2</a></li>
  <li><a href="../../../../v2.2.0/index.html">v2.2.0</a></li>
  <li><a href="../../../../v2.2.1/index.html">v2.2.1</a></li>
  <li><a href="../../../../v2.2.post0/index.html">v2.2.post0</a></li>
  <li><a href="../../../../v2.3.0/index.html">v2.3.0</a></li>
  <li><a href="../../../../v2.3.1/index.html">v2.3.1</a></li>
  <li><a href="../../../../v2.3.2/index.html">v2.3.2</a></li>
  <li><a href="../../../../v2.3.2rc1/index.html">v2.3.2rc1</a></li>
  <li><a href="nodestats.html">v2.3.2rc2</a></li>
  <li><a href="../../../../main/index.html">main</a></li>
</ul>
</div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    
    <li class="breadcrumb-item"><a href="../../topostats.html" class="nav-link">topostats</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">topostats.tracing.nodestats</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for topostats.tracing.nodestats</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Perform Crossing Region Processing and Analysis.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_dilation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">argrelextrema</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.morphology</span><span class="w"> </span><span class="kn">import</span> <span class="n">label</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">topostats.logs.logs</span><span class="w"> </span><span class="kn">import</span> <span class="n">LOGGER_NAME</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">topostats.measure.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">calculate_shortest_branch_distances</span><span class="p">,</span>
    <span class="n">connect_best_matches</span><span class="p">,</span>
    <span class="n">find_branches_for_nodes</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">topostats.tracing.pruning</span><span class="w"> </span><span class="kn">import</span> <span class="n">prune_skeleton</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">topostats.tracing.skeletonize</span><span class="w"> </span><span class="kn">import</span> <span class="n">getSkeleton</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">topostats.tracing.tracingfuncs</span><span class="w"> </span><span class="kn">import</span> <span class="n">order_branch</span><span class="p">,</span> <span class="n">order_branch_from_start</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">topostats.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">ResolutionError</span><span class="p">,</span> <span class="n">convolve_skeleton</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">LOGGER_NAME</span><span class="p">)</span>

<span class="c1"># pylint: disable=too-many-arguments</span>
<span class="c1"># pylint: disable=too-many-positional-arguments</span>
<span class="c1"># pylint: disable=too-many-branches</span>
<span class="c1"># pylint: disable=too-many-instance-attributes</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="c1"># pylint: disable=too-many-locals</span>
<span class="c1"># pylint: disable=too-many-nested-blocks</span>
<span class="c1"># pylint: disable=too-many-public-methods</span>
<span class="c1"># pylint: disable=too-many-statements</span>


<div class="viewcode-block" id="MatchedBranch">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.MatchedBranch">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MatchedBranch</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary containing the matched branches.</span>

<span class="sd">    matched_branches: dict[int, dict[str, npt.NDArray[np.number]]]</span>
<span class="sd">        Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">        keys:</span>
<span class="sd">        - &quot;ordered_coords&quot; : npt.NDArray[np.int32]. The ordered coordinates of the branch.</span>
<span class="sd">        - &quot;heights&quot; : npt.NDArray[np.number]. Heights of the branch coordinates.</span>
<span class="sd">        - &quot;distances&quot; : npt.NDArray[np.number]. Distances of the branch coordinates.</span>
<span class="sd">        - &quot;fwhm&quot; : npt.NDArray[np.number]. Full width half maximum of the branch.</span>
<span class="sd">        - &quot;angles&quot; : np.float64. The initial direction angle of the branch, added in later steps.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ordered_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span>
    <span class="n">heights</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span>
    <span class="n">distances</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span>
    <span class="n">fwhm</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span>
    <span class="n">angles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">|</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="NodeDict">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.NodeDict">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeDict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dictionary containing the node information.&quot;&quot;&quot;</span>

    <span class="n">error</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">pixel_to_nm_scaling</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="n">branch_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">MatchedBranch</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">node_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">confidence</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">|</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="ImageDict">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.ImageDict">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ImageDict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dictionary containing the image information.&quot;&quot;&quot;</span>

    <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]]</span>
    <span class="n">grain</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]]</span></div>



<div class="viewcode-block" id="nodeStats">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">nodeStats</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class containing methods to find and analyse the nodes/crossings within a grain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The name of the file being processed. For logging purposes.</span>
<span class="sd">    image : npt.npt.NDArray</span>
<span class="sd">        The array of pixels.</span>
<span class="sd">    mask : npt.npt.NDArray</span>
<span class="sd">        The binary segmentation mask.</span>
<span class="sd">    smoothed_mask : npt.NDArray</span>
<span class="sd">        A smoothed version of the bianary segmentation mask.</span>
<span class="sd">    skeleton : npt.NDArray</span>
<span class="sd">        A binary single-pixel wide mask of objects in the &#39;image&#39;.</span>
<span class="sd">    pixel_to_nm_scaling : np.float32</span>
<span class="sd">        The pixel to nm scaling factor.</span>
<span class="sd">    n_grain : int</span>
<span class="sd">        The grain number.</span>
<span class="sd">    node_joining_length : float</span>
<span class="sd">        The length over which to join skeletal intersections to be counted as one crossing.</span>
<span class="sd">    node_joining_length : float</span>
<span class="sd">        The distance over which to join nearby odd-branched nodes.</span>
<span class="sd">    node_extend_dist : float</span>
<span class="sd">        The distance under which to join odd-branched node regions.</span>
<span class="sd">    branch_pairing_length : float</span>
<span class="sd">        The length from the crossing point to pair and trace, obtaining FWHM&#39;s.</span>
<span class="sd">    pair_odd_branches : bool</span>
<span class="sd">        Whether to try and pair odd-branched nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">smoothed_mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">skeleton</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">pixel_to_nm_scaling</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">n_grain</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">node_joining_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">node_extend_dist</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">branch_pairing_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">pair_odd_branches</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the nodeStats class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The name of the file being processed. For logging purposes.</span>
<span class="sd">        image : npt.NDArray</span>
<span class="sd">            The array of pixels.</span>
<span class="sd">        mask : npt.NDArray</span>
<span class="sd">            The binary segmentation mask.</span>
<span class="sd">        smoothed_mask : npt.NDArray</span>
<span class="sd">            A smoothed version of the bianary segmentation mask.</span>
<span class="sd">        skeleton : npt.NDArray</span>
<span class="sd">            A binary single-pixel wide mask of objects in the &#39;image&#39;.</span>
<span class="sd">        pixel_to_nm_scaling : float</span>
<span class="sd">            The pixel to nm scaling factor.</span>
<span class="sd">        n_grain : int</span>
<span class="sd">            The grain number.</span>
<span class="sd">        node_joining_length : float</span>
<span class="sd">            The length over which to join skeletal intersections to be counted as one crossing.</span>
<span class="sd">        node_joining_length : float</span>
<span class="sd">            The distance over which to join nearby odd-branched nodes.</span>
<span class="sd">        node_extend_dist : float</span>
<span class="sd">            The distance under which to join odd-branched node regions.</span>
<span class="sd">        branch_pairing_length : float</span>
<span class="sd">            The length from the crossing point to pair and trace, obtaining FWHM&#39;s.</span>
<span class="sd">        pair_odd_branches : bool</span>
<span class="sd">            Whether to try and pair odd-branched nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_mask</span> <span class="o">=</span> <span class="n">smoothed_mask</span>  <span class="c1"># only used to average traces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">skeleton</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span> <span class="o">=</span> <span class="n">pixel_to_nm_scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_grain</span> <span class="o">=</span> <span class="n">n_grain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_joining_length</span> <span class="o">=</span> <span class="n">node_joining_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_extend_dist</span> <span class="o">=</span> <span class="n">node_extend_dist</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_pairing_length</span> <span class="o">=</span> <span class="n">branch_pairing_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pair_odd_branches</span> <span class="o">=</span> <span class="n">pair_odd_branches</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv_skelly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_connected_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whole_skel_graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_centre_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;num_crossings&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;avg_crossing_confidence&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;min_crossing_confidence&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_dicts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NodeDict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_dict</span><span class="p">:</span> <span class="n">ImageDict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="p">{},</span>
            <span class="s2">&quot;grain&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;grain_image&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                <span class="s2">&quot;grain_mask&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                <span class="s2">&quot;grain_skeleton&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">full_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visuals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_visuals_img</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="nodeStats.get_node_stats">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.get_node_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the workflow to obtain the node statistics.</span>

<span class="sd">        .. code-block:: RST</span>

<span class="sd">            node_dict key structure:  &lt;grain_number&gt;</span>
<span class="sd">                                        └-&gt; &lt;node_number&gt;</span>
<span class="sd">                                            |-&gt; &#39;error&#39;</span>
<span class="sd">                                            └-&gt; &#39;node_coords&#39;</span>
<span class="sd">                                            └-&gt; &#39;branch_stats&#39;</span>
<span class="sd">                                                └-&gt; &lt;branch_number&gt;</span>
<span class="sd">                                                    |-&gt; &#39;ordered_coords&#39;</span>
<span class="sd">                                                    |-&gt; &#39;heights&#39;</span>
<span class="sd">                                                    |-&gt; &#39;gaussian_fit&#39;</span>
<span class="sd">                                                    |-&gt; &#39;fwhm&#39;</span>
<span class="sd">                                                    └-&gt; &#39;angles&#39;</span>

<span class="sd">            image_dict key structure:  &#39;nodes&#39;</span>
<span class="sd">                                            &lt;node_number&gt;</span>
<span class="sd">                                                |-&gt; &#39;node_area_skeleton&#39;</span>
<span class="sd">                                                |-&gt; &#39;node_branch_mask&#39;</span>
<span class="sd">                                                └-&gt; &#39;node_avg_mask</span>
<span class="sd">                                        &#39;grain&#39;</span>
<span class="sd">                                            |-&gt; &#39;grain_image&#39;</span>
<span class="sd">                                            |-&gt; &#39;grain_mask&#39;</span>
<span class="sd">                                            └-&gt; &#39;grain_skeleton&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[dict, dict]</span>
<span class="sd">            Dictionaries of the node_information and images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node Stats - Processing Grain: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grain</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_skelly</span> <span class="o">=</span> <span class="n">convolve_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_skelly</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_skelly</span> <span class="o">==</span> <span class="mi">3</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># check if any nodes</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Nodestats - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grain</span><span class="si">}</span><span class="s2"> contains crossings.&quot;</span><span class="p">)</span>
            <span class="c1"># convolve to see crossing and end points</span>
            <span class="c1"># self.conv_skelly = self.tidy_branches(self.conv_skelly, self.image)</span>
            <span class="c1"># reset skeleton var as tidy branches may have modified it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_skelly</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_dict</span><span class="p">[</span><span class="s2">&quot;grain&quot;</span><span class="p">][</span><span class="s2">&quot;grain_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span>
            <span class="c1"># get graph of skeleton</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">whole_skel_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton_image_to_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
            <span class="c1"># connect the close nodes</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Nodestats - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grain</span><span class="si">}</span><span class="s2"> connecting close nodes.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_close_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_skelly</span><span class="p">,</span> <span class="n">node_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_joining_length</span><span class="p">)</span>
            <span class="c1"># connect the odd-branch nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_extended_nodes_nearest</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span><span class="p">,</span> <span class="n">node_extend_dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_extend_dist</span>
            <span class="p">)</span>
            <span class="c1"># obtain a mask of node centers and their count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_centre_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highlight_node_centres</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span><span class="p">)</span>
            <span class="c1"># Begin the hefty crossing analysis</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Nodestats - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grain</span><span class="si">}</span><span class="s2"> analysing found crossings.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyse_nodes</span><span class="p">(</span><span class="n">max_branch_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_pairing_length</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_metrics</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Nodestats - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grain</span><span class="si">}</span><span class="s2"> has no crossings.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_dicts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_dict</span></div>

        <span class="c1"># self.all_visuals_img = dnaTrace.concat_images_in_dict(self.image.shape, self.visuals)</span>

<div class="viewcode-block" id="nodeStats.skeleton_image_to_graph">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.skeleton_image_to_graph">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">skeleton_image_to_graph</span><span class="p">(</span><span class="n">skeleton</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a skeletonised mask into a Graph representation.</span>

<span class="sd">        Graphs conserve the coordinates via the node label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skeleton : npt.NDArray</span>
<span class="sd">            A binary single-pixel wide mask, or result from conv_skelly().</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.classes.graph.Graph</span>
<span class="sd">            A networkX graph connecting the pixels in the skeleton to their neighbours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skeImPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">skeImPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">neighIdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">curNeighPos</span> <span class="o">=</span> <span class="n">skeImPos</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">neigh</span><span class="p">[</span><span class="n">neighIdx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">curNeighPos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">curNeighPos</span> <span class="o">&gt;=</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">curNeighPos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curNeighPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">idx_coord</span> <span class="o">=</span> <span class="n">skeImPos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">skeImPos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
                    <span class="n">curNeigh_coord</span> <span class="o">=</span> <span class="n">curNeighPos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curNeighPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># assign lower weight to nodes if not a binary image</span>
                    <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">idx_coord</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">curNeigh_coord</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">idx_coord</span><span class="p">,</span> <span class="n">curNeigh_coord</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s2">&quot;physicalPos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">skeImPos</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="nodeStats.graph_to_skeleton_image">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.graph_to_skeleton_image">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">graph_to_skeleton_image</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the skeleton graph back to a binary image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        g : nx.Graph</span>
<span class="sd">            Graph with coordinates as node labels.</span>
<span class="sd">        im_shape : tuple[int]</span>
<span class="sd">            The shape of the image to dump.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            Skeleton binary image from the graph representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">im_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="n">im</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="nodeStats.tidy_branches">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.tidy_branches">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tidy_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connect_node_mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrangle distant connected nodes back towards the main cluster.</span>

<span class="sd">        Works by filling and reskeletonising soely the node areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        connect_node_mask : npt.NDArray</span>
<span class="sd">            The connected node mask - a skeleton where node regions = 3, endpoints = 2, and skeleton = 1.</span>
<span class="sd">        image : npt.NDArray</span>
<span class="sd">            The intensity image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            The wrangled connected_node_mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">connect_node_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">labeled_nodes</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">connect_node_mask</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">node_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">labeled_nodes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">solo_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labeled_nodes</span> <span class="o">==</span> <span class="n">node_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">solo_node</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">node_centre</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">node_wid</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># +2 so always 2 by default</span>
            <span class="n">node_len</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># +2 so always 2 by default</span>
            <span class="n">overflow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="p">)</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="c1"># grain mask fill</span>
            <span class="n">new_skeleton</span><span class="p">[</span>
                <span class="n">node_centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_wid</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">overflow</span> <span class="p">:</span> <span class="n">node_centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">node_wid</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">overflow</span><span class="p">,</span>
                <span class="n">node_centre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_len</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">overflow</span> <span class="p">:</span> <span class="n">node_centre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">node_len</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">overflow</span><span class="p">,</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span>
                <span class="n">node_centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_wid</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">overflow</span> <span class="p">:</span> <span class="n">node_centre</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">node_wid</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">overflow</span><span class="p">,</span>
                <span class="n">node_centre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_len</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">overflow</span> <span class="p">:</span> <span class="n">node_centre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">node_len</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">overflow</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="c1"># remove any artifacts of the grain caught in the overflow areas</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_biggest_object</span><span class="p">(</span><span class="n">new_skeleton</span><span class="p">)</span>
        <span class="c1"># Re-skeletonise</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">getSkeleton</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">new_skeleton</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;topostats&quot;</span><span class="p">,</span> <span class="n">height_bias</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">()</span>
        <span class="c1"># new_skeleton = pruneSkeleton(image, new_skeleton).prune_skeleton(</span>
        <span class="c1">#     {&quot;method&quot;: &quot;topostats&quot;, &quot;max_length&quot;: -1}</span>
        <span class="c1"># )</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">prune_skeleton</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">new_skeleton</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;topostats&quot;</span><span class="p">,</span> <span class="s2">&quot;max_length&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># cleanup around nibs</span>
        <span class="n">new_skeleton</span> <span class="o">=</span> <span class="n">getSkeleton</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">new_skeleton</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;zhang&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">()</span>
        <span class="c1"># might also need to remove segments that have squares connected</span>

        <span class="k">return</span> <span class="n">convolve_skeleton</span><span class="p">(</span><span class="n">new_skeleton</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats.keep_biggest_object">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.keep_biggest_object">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">keep_biggest_object</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retain the largest object in a binary mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : npt.NDArray</span>
<span class="sd">            Binary mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            A binary mask with only one object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labelled_mask</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">idxs</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labelled_mask</span> <span class="o">==</span> <span class="n">max_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">: mask is empty.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="nodeStats.connect_close_nodes">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.connect_close_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect_close_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv_skelly</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">node_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.85</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect nodes within the &#39;node_width&#39; boundary distance.</span>

<span class="sd">        This labels them as part of the same node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conv_skelly : npt.NDArray</span>
<span class="sd">            A labeled skeleton image with skeleton = 1, endpoints = 2, crossing points =3.</span>
<span class="sd">        node_width : float</span>
<span class="sd">            The width of the dna in the grain, used to connect close nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The skeleton (label=1) with close nodes connected (label=3).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">=</span> <span class="n">conv_skelly</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nodeless</span> <span class="o">=</span> <span class="n">conv_skelly</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nodeless</span><span class="p">[(</span><span class="n">nodeless</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">nodeless</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># remove node &amp; termini points</span>
        <span class="n">nodeless_labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">nodeless</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodeless_labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodeless</span><span class="p">[</span><span class="n">nodeless_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">node_width</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="p">):</span>
                <span class="c1"># maybe also need to select based on height? and also ensure small branches classified</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span><span class="p">[</span><span class="n">nodeless_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span></div>


<div class="viewcode-block" id="nodeStats.highlight_node_centres">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.highlight_node_centres">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">highlight_node_centres</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the node centres based on height and re-plot on the mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : npt.NDArray</span>
<span class="sd">            2D array with background = 0, skeleton = 1, endpoints = 2, node_centres = 3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            2D array with the highest node coordinate for each node labeled as 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">small_node_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">small_node_mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># remap nodes to skeleton</span>
        <span class="n">big_nodes</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">big_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># remove non-nodes &amp; set nodes to 1</span>
        <span class="n">big_node_mask</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">big_nodes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">big_node_mask</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># get node indices</span>
            <span class="n">centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="p">(</span><span class="n">big_node_mask</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">small_node_mask</span><span class="p">[</span><span class="n">centre</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">return</span> <span class="n">small_node_mask</span></div>


<div class="viewcode-block" id="nodeStats.connect_extended_nodes_nearest">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.connect_extended_nodes_nearest">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">connect_extended_nodes_nearest</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">connected_nodes</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">node_extend_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the odd branched nodes to other odd branched nodes within the &#39;extend_dist&#39; threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        connected_nodes : npt.NDArray</span>
<span class="sd">            A 2D array representing the network with background = 0, skeleton = 1, endpoints = 2,</span>
<span class="sd">            node_centres = 3.</span>
<span class="sd">        node_extend_dist : int | float, optional</span>
<span class="sd">            The distance over which to connect odd-branched nodes, by default -1 for no-limit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray[np.int32]</span>
<span class="sd">            Connected nodes array with odd-branched nodes connected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">just_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">connected_nodes</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># remove branches &amp; termini points</span>
        <span class="n">labelled_nodes</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">just_nodes</span><span class="p">)</span>

        <span class="n">just_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">connected_nodes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># remove node &amp; termini points</span>
        <span class="n">just_branches</span><span class="p">[</span><span class="n">connected_nodes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">labelled_nodes</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">labelled_branches</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">just_branches</span><span class="p">)</span>

        <span class="n">nodes_with_branch_starting_coords</span> <span class="o">=</span> <span class="n">find_branches_for_nodes</span><span class="p">(</span>
            <span class="n">network_array_representation</span><span class="o">=</span><span class="n">connected_nodes</span><span class="p">,</span>
            <span class="n">labelled_nodes</span><span class="o">=</span><span class="n">labelled_nodes</span><span class="p">,</span>
            <span class="n">labelled_branches</span><span class="o">=</span><span class="n">labelled_branches</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If there is only one node, then there is no need to connect the nodes since there is nothing to</span>
        <span class="c1"># connect it to. Return the original connected_nodes instead.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_with_branch_starting_coords</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">=</span> <span class="n">connected_nodes</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">whole_skel_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Whole skeleton graph is not defined.&quot;</span>  <span class="c1"># for type safety</span>
        <span class="n">shortest_node_dists</span><span class="p">,</span> <span class="n">shortest_dists_branch_idxs</span><span class="p">,</span> <span class="n">_shortest_dist_coords</span> <span class="o">=</span> <span class="n">calculate_shortest_branch_distances</span><span class="p">(</span>
            <span class="n">nodes_with_branch_starting_coords</span><span class="o">=</span><span class="n">nodes_with_branch_starting_coords</span><span class="p">,</span>
            <span class="n">whole_skeleton_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">whole_skel_graph</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Matches is an Nx2 numpy array of indexes of the best matching nodes.</span>
        <span class="c1"># Eg: np.array([[1, 0], [2, 3]]) means that the best matching nodes are</span>
        <span class="c1"># node 1 and node 0, and node 2 and node 3.</span>
        <span class="n">matches</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_matches</span><span class="p">(</span><span class="n">shortest_node_dists</span><span class="p">,</span> <span class="n">max_weight_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Connect the nodes by their best matches, using the shortest distances between their branch starts.</span>
        <span class="n">connected_nodes</span> <span class="o">=</span> <span class="n">connect_best_matches</span><span class="p">(</span>
            <span class="n">network_array_representation</span><span class="o">=</span><span class="n">connected_nodes</span><span class="p">,</span>
            <span class="n">whole_skeleton_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">whole_skel_graph</span><span class="p">,</span>
            <span class="n">match_indexes</span><span class="o">=</span><span class="n">matches</span><span class="p">,</span>
            <span class="n">shortest_distances_between_nodes</span><span class="o">=</span><span class="n">shortest_node_dists</span><span class="p">,</span>
            <span class="n">shortest_distances_branch_indexes</span><span class="o">=</span><span class="n">shortest_dists_branch_idxs</span><span class="p">,</span>
            <span class="n">emanating_branch_starts_by_node</span><span class="o">=</span><span class="n">nodes_with_branch_starting_coords</span><span class="p">,</span>
            <span class="n">extend_distance</span><span class="o">=</span><span class="n">node_extend_dist</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">=</span> <span class="n">connected_nodes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span></div>


<div class="viewcode-block" id="nodeStats.find_branch_starts">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.find_branch_starts">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_branch_starts</span><span class="p">(</span><span class="n">reduced_node_image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the coordinates where the branches connect to the node region through binary dilation of the node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduced_node_image : npt.NDArray</span>
<span class="sd">            A 2D numpy array containing a single node region (=3) and its connected branches (=1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            Coordinate array of pixels next to crossing points (=3 in input).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reduced_node_image</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">nodeless</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reduced_node_image</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">thick_node</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">thick_node</span> <span class="o">*</span> <span class="n">nodeless</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># pylint: disable=too-many-locals</span>
<div class="viewcode-block" id="nodeStats.analyse_nodes">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.analyse_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">analyse_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_branch_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain the main analyses for the nodes of a single molecule along the &#39;max_branch_length&#39;(nm) from the node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_branch_length : float</span>
<span class="sd">            The side length of the box around the node to analyse (in nm).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get coordinates of nodes</span>
        <span class="c1"># This is a numpy array of coords, shape Nx2</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_centre_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Node centre mask is not defined.&quot;</span>
        <span class="n">node_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_centre_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Check whether average trace resides inside the grain mask</span>
        <span class="c1"># Checks if we dilate the skeleton once or twice, then all the pixels should fit in the grain mask</span>
        <span class="n">dilate</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># This flag determines whether to use average of 3 traces in calculation of FWHM</span>
        <span class="n">average_trace_advised</span> <span class="o">=</span> <span class="n">dilate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">dilate</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Branch height traces will be averaged: </span><span class="si">{</span><span class="n">average_trace_advised</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Iterate over the nodes and analyse the branches</span>
        <span class="n">matched_branches</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">branch_image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">avg_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">real_node_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node_no</span><span class="p">,</span> <span class="p">(</span><span class="n">node_x</span><span class="p">,</span> <span class="n">node_y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_coords</span><span class="p">):</span>
            <span class="n">unmatched_branches</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Get branches relevant to the node</span>
            <span class="n">max_length_px</span> <span class="o">=</span> <span class="n">max_branch_length</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">reduced_node_area</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">only_centre_branches</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node_x</span><span class="p">,</span> <span class="n">node_y</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="c1"># Reduced skel graph is a networkx graph of the reduced node area.</span>
            <span class="n">reduced_skel_graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">skeleton_image_to_graph</span><span class="p">(</span><span class="n">reduced_node_area</span><span class="p">)</span>

            <span class="c1"># Binarise the reduced node area</span>
            <span class="n">branch_mask</span> <span class="o">=</span> <span class="n">reduced_node_area</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">branch_mask</span><span class="p">[</span><span class="n">branch_mask</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">branch_mask</span><span class="p">[</span><span class="n">branch_mask</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">node_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">reduced_node_area</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># Find the starting coordinates of any branches connected to the node</span>
            <span class="n">branch_start_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_branch_starts</span><span class="p">(</span><span class="n">reduced_node_area</span><span class="p">)</span>

            <span class="c1"># Stop processing if nib (node has 2 branches)</span>
            <span class="k">if</span> <span class="n">branch_start_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">node_no</span><span class="si">}</span><span class="s2"> has only two branches - skipped &amp; nodes removed.</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node_coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;pixels in nib node.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">real_node_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node: </span><span class="si">{</span><span class="n">real_node_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Analyse the node branches</span>
                    <span class="p">(</span>
                        <span class="n">pairs</span><span class="p">,</span>
                        <span class="n">matched_branches</span><span class="p">,</span>
                        <span class="n">ordered_branches</span><span class="p">,</span>
                        <span class="n">masked_image</span><span class="p">,</span>
                        <span class="n">branch_under_over_order</span><span class="p">,</span>
                        <span class="n">confidence</span><span class="p">,</span>
                        <span class="n">singlet_branch_vectors</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">analyse_node_branches</span><span class="p">(</span>
                        <span class="n">p_to_nm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="p">,</span>
                        <span class="n">reduced_node_area</span><span class="o">=</span><span class="n">reduced_node_area</span><span class="p">,</span>
                        <span class="n">branch_start_coords</span><span class="o">=</span><span class="n">branch_start_coords</span><span class="p">,</span>
                        <span class="n">max_length_px</span><span class="o">=</span><span class="n">max_length_px</span><span class="p">,</span>
                        <span class="n">reduced_skeleton_graph</span><span class="o">=</span><span class="n">reduced_skel_graph</span><span class="p">,</span>
                        <span class="n">image</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                        <span class="n">average_trace_advised</span><span class="o">=</span><span class="n">average_trace_advised</span><span class="p">,</span>
                        <span class="n">node_coord</span><span class="o">=</span><span class="p">(</span><span class="n">node_x</span><span class="p">,</span> <span class="n">node_y</span><span class="p">),</span>
                        <span class="n">pair_odd_branches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_odd_branches</span><span class="p">,</span>
                        <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                        <span class="n">resolution_threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="mi">512</span><span class="p">),</span>
                    <span class="p">)</span>

                    <span class="c1"># Add the analysed branches to the labelled image</span>
                    <span class="n">branch_image</span><span class="p">,</span> <span class="n">avg_image</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">add_branches_to_labelled_image</span><span class="p">(</span>
                        <span class="n">branch_under_over_order</span><span class="o">=</span><span class="n">branch_under_over_order</span><span class="p">,</span>
                        <span class="n">matched_branches</span><span class="o">=</span><span class="n">matched_branches</span><span class="p">,</span>
                        <span class="n">masked_image</span><span class="o">=</span><span class="n">masked_image</span><span class="p">,</span>
                        <span class="n">branch_start_coords</span><span class="o">=</span><span class="n">branch_start_coords</span><span class="p">,</span>
                        <span class="n">ordered_branches</span><span class="o">=</span><span class="n">ordered_branches</span><span class="p">,</span>
                        <span class="n">pairs</span><span class="o">=</span><span class="n">pairs</span><span class="p">,</span>
                        <span class="n">average_trace_advised</span><span class="o">=</span><span class="n">average_trace_advised</span><span class="p">,</span>
                        <span class="n">image_shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="p">)</span>

                    <span class="c1"># Calculate crossing angles of unpaired branches and add to stats dict</span>
                    <span class="n">nodestats_calc_singlet_angles_result</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">singlet_branch_vectors</span><span class="p">))</span>
                    <span class="n">angles_between_singlet_branch_vectors</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">nodestats_calc_singlet_angles_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="k">for</span> <span class="n">branch_index</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles_between_singlet_branch_vectors</span><span class="p">):</span>
                        <span class="n">unmatched_branches</span><span class="p">[</span><span class="n">branch_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;angles&quot;</span><span class="p">:</span> <span class="n">angle</span><span class="p">}</span>

                    <span class="c1"># Get the vector of each branch based on ordered_coords. Ordered_coords is only the first N nm</span>
                    <span class="c1"># of the branch so this is just a general vibe on what direction a branch is going.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_start_coords</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_odd_branches</span><span class="p">:</span>
                        <span class="n">vectors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">matched_branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeStats</span><span class="o">.</span><span class="n">get_vector</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;ordered_coords&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node_x</span><span class="p">,</span> <span class="n">node_y</span><span class="p">])))</span>
                        <span class="c1"># Calculate angles between the vectors</span>
                        <span class="n">nodestats_calc_angles_result</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vectors</span><span class="p">))</span>
                        <span class="n">angles_between_vectors_along_branch</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodestats_calc_angles_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">branch_index</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles_between_vectors_along_branch</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_start_coords</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pair_odd_branches</span><span class="p">:</span>
                                <span class="n">matched_branches</span><span class="p">[</span><span class="n">branch_index</span><span class="p">][</span><span class="s2">&quot;angles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">image_dict</span><span class="p">[</span><span class="s2">&quot;grain&quot;</span><span class="p">][</span><span class="s2">&quot;grain_skeleton&quot;</span><span class="p">][</span><span class="n">node_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">node_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Eg: length 2 array: [array([ nan, 79.00]), array([79.00, 0.0])]</span>
                    <span class="c1"># angles_between_vectors_along_branch</span>

                <span class="k">except</span> <span class="n">ResolutionError</span><span class="p">:</span>
                    <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node stats skipped as resolution too low: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="si">}</span><span class="s2">nm per pixel&quot;</span><span class="p">)</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">node_dicts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;node_</span><span class="si">{</span><span class="n">real_node_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="n">error</span><span class="p">,</span>
                    <span class="s2">&quot;pixel_to_nm_scaling&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_to_nm_scaling</span><span class="p">,</span>
                    <span class="s2">&quot;branch_stats&quot;</span><span class="p">:</span> <span class="n">matched_branches</span><span class="p">,</span>
                    <span class="s2">&quot;unmatched_branch_stats&quot;</span><span class="p">:</span> <span class="n">unmatched_branches</span><span class="p">,</span>
                    <span class="s2">&quot;node_coords&quot;</span><span class="p">:</span> <span class="n">node_coords</span><span class="p">,</span>
                    <span class="s2">&quot;confidence&quot;</span><span class="p">:</span> <span class="n">confidence</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="k">assert</span> <span class="n">reduced_node_area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Reduced node area is not defined.&quot;</span>
                <span class="k">assert</span> <span class="n">branch_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Branch image is not defined.&quot;</span>
                <span class="k">assert</span> <span class="n">avg_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Average image is not defined.&quot;</span>
                <span class="n">node_images_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;node_area_skeleton&quot;</span><span class="p">:</span> <span class="n">reduced_node_area</span><span class="p">,</span>
                    <span class="s2">&quot;node_branch_mask&quot;</span><span class="p">:</span> <span class="n">branch_image</span><span class="p">,</span>
                    <span class="s2">&quot;node_avg_mask&quot;</span><span class="p">:</span> <span class="n">avg_image</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image_dict</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;node_</span><span class="si">{</span><span class="n">real_node_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_images_dict</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">all_connected_nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">connected_nodes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span></div>


    <span class="c1"># pylint: disable=too-many-arguments</span>
<div class="viewcode-block" id="nodeStats.add_branches_to_labelled_image">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.add_branches_to_labelled_image">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_branches_to_labelled_image</span><span class="p">(</span>
        <span class="n">branch_under_over_order</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">matched_branches</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">MatchedBranch</span><span class="p">],</span>
        <span class="n">masked_image</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]]],</span>
        <span class="n">branch_start_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">ordered_branches</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
        <span class="n">pairs</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">average_trace_advised</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">image_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add branches to a labelled image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        branch_under_over_order : npt.NDArray[np.int32]</span>
<span class="sd">            The order of the branches.</span>
<span class="sd">        matched_branches : dict[int, dict[str, MatchedBranch]]</span>
<span class="sd">            Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">            keys:</span>
<span class="sd">            - &quot;ordered_coords&quot; : npt.NDArray[np.int32].</span>
<span class="sd">            - &quot;heights&quot; : npt.NDArray[np.number]. Heights of the branches.</span>
<span class="sd">            - &quot;distances&quot; :</span>
<span class="sd">            - &quot;fwhm&quot; : npt.NDArray[np.number]. Full width half maximum of the branches.</span>
<span class="sd">        masked_image : dict[int, dict[str, npt.NDArray[np.bool_]]]</span>
<span class="sd">            Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">            keys:</span>
<span class="sd">            - &quot;avg_mask&quot; : npt.NDArray[np.bool_]. Average mask of the branches.</span>
<span class="sd">        branch_start_coords : npt.NDArray[np.int32]</span>
<span class="sd">            An Nx2 numpy array of the coordinates of the branches connected to the node.</span>
<span class="sd">        ordered_branches : list[npt.NDArray[np.int32]]</span>
<span class="sd">            List of numpy arrays of ordered branch coordinates.</span>
<span class="sd">        pairs : npt.NDArray[np.int32]</span>
<span class="sd">            Nx2 numpy array of pairs of branches that are matched through a node.</span>
<span class="sd">        average_trace_advised : bool</span>
<span class="sd">            Flag to determine whether to use the average trace.</span>
<span class="sd">        image_shape : tuple[int]</span>
<span class="sd">            The shape of the image, to create a mask from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[npt.NDArray[np.int32], npt.NDArray[np.int32]]</span>
<span class="sd">            The branch image and the average image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">branch_image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">avg_image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">branch_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_under_over_order</span><span class="p">):</span>
            <span class="n">branch_coords</span> <span class="o">=</span> <span class="n">matched_branches</span><span class="p">[</span><span class="n">branch_index</span><span class="p">][</span><span class="s2">&quot;ordered_coords&quot;</span><span class="p">]</span>

            <span class="c1"># Add the matched branch to the image, starting at index 1</span>
            <span class="n">branch_image</span><span class="p">[</span><span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">average_trace_advised</span><span class="p">:</span>
                <span class="c1"># For type safety, check if avg_image is None and skip if so.</span>
                <span class="c1"># This is because the type hinting does not allow for None in the array.</span>
                <span class="n">avg_image</span><span class="p">[</span><span class="n">masked_image</span><span class="p">[</span><span class="n">branch_index</span><span class="p">][</span><span class="s2">&quot;avg_mask&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Determine branches that were not able to be paired</span>
        <span class="n">unpaired_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">branch_start_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">pairs</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unpaired branches: </span><span class="si">{</span><span class="n">unpaired_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Ensure that unpaired branches start at index I where I is the number of paired branches.</span>
        <span class="n">branch_label</span> <span class="o">=</span> <span class="n">branch_image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="c1"># Add the unpaired branches back to the branch image</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpaired_branches</span><span class="p">:</span>
            <span class="n">branch_label</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">branch_image</span><span class="p">[</span><span class="n">ordered_branches</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ordered_branches</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">branch_label</span>

        <span class="k">return</span> <span class="n">branch_image</span><span class="p">,</span> <span class="n">avg_image</span></div>


<div class="viewcode-block" id="nodeStats.analyse_node_branches">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.analyse_node_branches">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">analyse_node_branches</span><span class="p">(</span>
        <span class="n">p_to_nm</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">reduced_node_area</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">branch_start_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">max_length_px</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="n">reduced_skeleton_graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
        <span class="n">average_trace_advised</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">node_coord</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">pair_odd_branches</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">resolution_threshold</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">MatchedBranch</span><span class="p">],</span>
        <span class="nb">list</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
        <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]]],</span>
        <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyse the branches of a single node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p_to_nm : np.float64</span>
<span class="sd">            The pixel to nm scaling factor.</span>
<span class="sd">        reduced_node_area : npt.NDArray[np.int32]</span>
<span class="sd">            An NxM numpy array of the node in question and the branches connected to it.</span>
<span class="sd">            Node is marked by 3, and branches by 1.</span>
<span class="sd">        branch_start_coords : npt.NDArray[np.int32]</span>
<span class="sd">            An Nx2 numpy array of the coordinates of the branches connected to the node.</span>
<span class="sd">        max_length_px : np.int32</span>
<span class="sd">            The maximum length in pixels to traverse along while ordering.</span>
<span class="sd">        reduced_skeleton_graph : nx.classes.graph.Graph</span>
<span class="sd">            The graph representation of the reduced node area.</span>
<span class="sd">        image : npt.NDArray[np.number]</span>
<span class="sd">            The full image of the grain.</span>
<span class="sd">        average_trace_advised : bool</span>
<span class="sd">            Flag to determine whether to use the average trace.</span>
<span class="sd">        node_coord : tuple[np.int32, np.int32]</span>
<span class="sd">            The node coordinates.</span>
<span class="sd">        pair_odd_branches : bool</span>
<span class="sd">            Whether to try and pair odd-branched nodes.</span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename of the image.</span>
<span class="sd">        resolution_threshold : np.float64</span>
<span class="sd">            The resolution threshold below which to warn the user that the node is difficult to analyse.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pairs: npt.NDArray[np.int32]</span>
<span class="sd">            Nx2 numpy array of pairs of branches that are matched through a node.</span>
<span class="sd">        matched_branches: dict[int, MatchedBranch]]</span>
<span class="sd">            Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">            keys:</span>
<span class="sd">            - &quot;ordered_coords&quot; : npt.NDArray[np.int32].</span>
<span class="sd">            - &quot;heights&quot; : npt.NDArray[np.number]. Heights of the branches.</span>
<span class="sd">            - &quot;distances&quot; : npt.NDArray[np.number]. The accumulating distance along the branch.</span>
<span class="sd">            - &quot;fwhm&quot; : npt.NDArray[np.number]. Full width half maximum of the branches.</span>
<span class="sd">            - &quot;angles&quot; : np.float64. The angle of the branch, added in later steps.</span>
<span class="sd">        ordered_branches: list[npt.NDArray[np.int32]]</span>
<span class="sd">            List of numpy arrays of ordered branch coordinates.</span>
<span class="sd">        masked_image: dict[int, dict[str, npt.NDArray[np.bool_]]]</span>
<span class="sd">            Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">            keys:</span>
<span class="sd">            - &quot;avg_mask&quot; : npt.NDArray[np.bool_]. Average mask of the branches.</span>
<span class="sd">        branch_under_over_order: npt.NDArray[np.int32]</span>
<span class="sd">            The order of the branches based on the FWHM.</span>
<span class="sd">        confidence: np.float64 | None</span>
<span class="sd">            The confidence of the crossing. Optional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p_to_nm</span> <span class="o">&lt;=</span> <span class="n">resolution_threshold</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resolution </span><span class="si">{</span><span class="n">p_to_nm</span><span class="si">}</span><span class="s2"> is below suggested </span><span class="si">{</span><span class="n">resolution_threshold</span><span class="si">}</span><span class="s2">, node difficult to analyse.&quot;</span><span class="p">)</span>

        <span class="c1"># Pixel-wise order the branches coming from the node and calculate the starting vector for each branch</span>
        <span class="n">ordered_branches</span><span class="p">,</span> <span class="n">singlet_branch_vectors</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">get_ordered_branches_and_vectors</span><span class="p">(</span>
            <span class="n">reduced_node_area</span><span class="p">,</span> <span class="n">branch_start_coords</span><span class="p">,</span> <span class="n">max_length_px</span>
        <span class="p">)</span>

        <span class="c1"># Pair the singlet branch vectors based on their suitability using vector orientation.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_start_coords</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pair_odd_branches</span><span class="p">:</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">pair_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">singlet_branch_vectors</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Match the branches up</span>
        <span class="n">matched_branches</span><span class="p">,</span> <span class="n">masked_image</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">join_matching_branches_through_node</span><span class="p">(</span>
            <span class="n">pairs</span><span class="p">,</span>
            <span class="n">ordered_branches</span><span class="p">,</span>
            <span class="n">reduced_skeleton_graph</span><span class="p">,</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="n">average_trace_advised</span><span class="p">,</span>
            <span class="n">node_coord</span><span class="p">,</span>
            <span class="n">filename</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Redo the FWHMs after the processing for more accurate determination of under/overs.</span>
        <span class="n">hms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">matched_branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">hms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">][</span><span class="s2">&quot;half_maxs&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">matched_branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">calculate_fwhm</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;heights&quot;</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">],</span> <span class="n">hm</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">hms</span><span class="p">))</span>

        <span class="c1"># Get the confidence of the crossing</span>
        <span class="n">crossing_fwhms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">matched_branches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">crossing_fwhms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">][</span><span class="s2">&quot;fwhm&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crossing_fwhms</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crossing_fwhm_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">crossing_fwhms</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">nodeStats</span><span class="o">.</span><span class="n">cross_confidence</span><span class="p">(</span><span class="n">crossing_fwhm_combinations</span><span class="p">))</span>

        <span class="c1"># Order the branch indexes based on the FWHM of the branches.</span>
        <span class="n">branch_under_over_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">matched_branches</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">crossing_fwhms</span><span class="p">))]</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pairs</span><span class="p">,</span>
            <span class="n">matched_branches</span><span class="p">,</span>
            <span class="n">ordered_branches</span><span class="p">,</span>
            <span class="n">masked_image</span><span class="p">,</span>
            <span class="n">branch_under_over_order</span><span class="p">,</span>
            <span class="n">confidence</span><span class="p">,</span>
            <span class="n">singlet_branch_vectors</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats.join_matching_branches_through_node">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.join_matching_branches_through_node">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join_matching_branches_through_node</span><span class="p">(</span>
        <span class="n">pairs</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">ordered_branches</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
        <span class="n">reduced_skeleton_graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
        <span class="n">image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
        <span class="n">average_trace_advised</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">node_coords</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">MatchedBranch</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join branches that are matched through a node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pairs : npt.NDArray[np.int32]</span>
<span class="sd">            Nx2 numpy array of pairs of branches that are matched through a node.</span>
<span class="sd">        ordered_branches : list[npt.NDArray[np.int32]]</span>
<span class="sd">            List of numpy arrays of ordered branch coordinates.</span>
<span class="sd">        reduced_skeleton_graph : nx.classes.graph.Graph</span>
<span class="sd">            Graph representation of the skeleton.</span>
<span class="sd">        image : npt.NDArray[np.number]</span>
<span class="sd">            The full image of the grain.</span>
<span class="sd">        average_trace_advised : bool</span>
<span class="sd">            Flag to determine whether to use the average trace.</span>
<span class="sd">        node_coords : tuple[np.int32, np.int32]</span>
<span class="sd">            The node coordinates.</span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matched_branches: dict[int, dict[str, npt.NDArray[np.number]]]</span>
<span class="sd">            Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">            keys:</span>
<span class="sd">            - &quot;ordered_coords&quot; : npt.NDArray[np.int32].</span>
<span class="sd">            - &quot;heights&quot; : npt.NDArray[np.number]. Heights of the branches.</span>
<span class="sd">            - &quot;distances&quot; :</span>
<span class="sd">            - &quot;fwhm&quot; : npt.NDArray[np.number]. Full width half maximum of the branches.</span>
<span class="sd">        masked_image: dict[int, dict[str, npt.NDArray[np.bool_]]]</span>
<span class="sd">            Dictionary where the key is the index of the pair and the value is a dictionary containing the following</span>
<span class="sd">            keys:</span>
<span class="sd">            - &quot;avg_mask&quot; : npt.NDArray[np.bool_]. Average mask of the branches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matched_branches</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">MatchedBranch</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">masked_image</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{}</span>
        <span class="p">)</span>  <span class="c1"># Masked image is a dictionary of pairs of branches</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">branch_1</span><span class="p">,</span> <span class="n">branch_2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">matched_branches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MatchedBranch</span><span class="p">(</span>
                <span class="n">ordered_coords</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">heights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="n">distances</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="n">fwhm</span><span class="o">=</span><span class="p">{},</span>
                <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">masked_image</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># find close ends by rearranging branch coords</span>
            <span class="n">branch_1_coords</span><span class="p">,</span> <span class="n">branch_2_coords</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">order_branches</span><span class="p">(</span>
                <span class="n">ordered_branches</span><span class="p">[</span><span class="n">branch_1</span><span class="p">],</span> <span class="n">ordered_branches</span><span class="p">[</span><span class="n">branch_2</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># Get graphical shortest path between branch ends on the skeleton</span>
            <span class="n">crossing</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span>
                <span class="n">reduced_skeleton_graph</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">branch_1_coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">target</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">branch_2_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">crossing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">crossing</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># remove start and end points &amp; turn into array</span>
            <span class="c1"># Branch coords and crossing</span>
            <span class="k">if</span> <span class="n">crossing</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
                <span class="n">branch_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">branch_1_coords</span><span class="p">,</span> <span class="n">branch_2_coords</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">branch_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">branch_1_coords</span><span class="p">,</span> <span class="n">crossing</span><span class="p">,</span> <span class="n">branch_2_coords</span><span class="p">])</span>
            <span class="c1"># make images of single branch joined and multiple branches joined</span>
            <span class="n">single_branch_img</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">single_branch_img</span><span class="p">[</span><span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">single_branch_coords</span> <span class="o">=</span> <span class="n">order_branch</span><span class="p">(</span><span class="n">single_branch_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="c1"># calc image-wide coords</span>
            <span class="n">matched_branches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;ordered_coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_branch_coords</span>
            <span class="c1"># get heights and trace distance of branch</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">average_trace_advised</span>
                <span class="n">distances</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">average_height_trace</span><span class="p">(</span>
                    <span class="n">image</span><span class="p">,</span> <span class="n">single_branch_img</span><span class="p">,</span> <span class="n">single_branch_coords</span><span class="p">,</span> <span class="p">[</span><span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="n">masked_image</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;avg_mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">except</span> <span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">,</span>
                <span class="ne">IndexError</span><span class="p">,</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># Assertion - avg trace not advised, Index - wiggy branches</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : avg trace failed with </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">, single trace only.&quot;</span><span class="p">)</span>
                <span class="n">average_trace_advised</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">coord_dist_rad</span><span class="p">(</span><span class="n">single_branch_coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="c1"># distances = self.coord_dist(single_branch_coords)</span>
                <span class="n">zero_dist</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">single_branch_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="o">+</span> <span class="p">(</span><span class="n">single_branch_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">]</span>
                <span class="n">heights</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">single_branch_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">single_branch_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># self.hess</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">-</span> <span class="n">zero_dist</span>
                <span class="n">distances</span><span class="p">,</span> <span class="n">heights</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">average_uniques</span><span class="p">(</span>
                    <span class="n">distances</span><span class="p">,</span> <span class="n">heights</span>
                <span class="p">)</span>  <span class="c1"># needs to be paired with coord_dist_rad</span>
            <span class="n">matched_branches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;heights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">heights</span>
            <span class="n">matched_branches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;distances&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span>
            <span class="c1"># identify over/under</span>
            <span class="n">matched_branches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;fwhm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">calculate_fwhm</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matched_branches</span><span class="p">,</span> <span class="n">masked_image</span></div>


<div class="viewcode-block" id="nodeStats.get_ordered_branches_and_vectors">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.get_ordered_branches_and_vectors">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_ordered_branches_and_vectors</span><span class="p">(</span>
        <span class="n">reduced_node_area</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">branch_start_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">max_length_px</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ordered branches and vectors for a node.</span>

<span class="sd">        Branches are ordered so they are no longer just a disordered set of coordinates, and vectors are calculated to</span>
<span class="sd">        represent the general direction tendency of the branch, this allows for alignment matching later on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduced_node_area : npt.NDArray[np.int32]</span>
<span class="sd">            An NxM numpy array of the node in question and the branches connected to it.</span>
<span class="sd">            Node is marked by 3, and branches by 1.</span>
<span class="sd">        branch_start_coords : npt.NDArray[np.int32]</span>
<span class="sd">            An Px2 numpy array of coordinates representing the start of branches where P is the number of branches.</span>
<span class="sd">        max_length_px : np.int32</span>
<span class="sd">            The maximum length in pixels to traverse along while ordering.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[list[npt.NDArray[np.int32]], list[npt.NDArray[np.int32]]]</span>
<span class="sd">            A tuple containing a list of ordered branches and a list of vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordered_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodeless</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reduced_node_area</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch_start_coord</span> <span class="ow">in</span> <span class="n">branch_start_coords</span><span class="p">:</span>
            <span class="c1"># Order the branch coordinates so they&#39;re no longer just a disordered set of coordinates</span>
            <span class="n">ordered_branch</span> <span class="o">=</span> <span class="n">order_branch_from_start</span><span class="p">(</span><span class="n">nodeless</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">branch_start_coord</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="n">max_length_px</span><span class="p">)</span>
            <span class="n">ordered_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ordered_branch</span><span class="p">)</span>

            <span class="c1"># Calculate vector to represent the general direction tendency of the branch (for alignment matching)</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">get_vector</span><span class="p">(</span><span class="n">ordered_branch</span><span class="p">,</span> <span class="n">branch_start_coord</span><span class="p">)</span>
            <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ordered_branches</span><span class="p">,</span> <span class="n">vectors</span></div>


<div class="viewcode-block" id="nodeStats.cross_confidence">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.cross_confidence">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cross_confidence</span><span class="p">(</span><span class="n">pair_combinations</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain the average confidence of the combinations using a reciprical function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pair_combinations : list</span>
<span class="sd">            List of length 2 combinations of FWHM values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The average crossing confidence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pair_combinations</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">recip</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_combinations</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats.recip">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.recip">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">recip</span><span class="p">(</span><span class="n">vals</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1 - (max / min) of the two values provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vals : list</span>
<span class="sd">            List of 2 values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Result of applying the 1-(min / max) function to the two values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># means fwhm variation hasn&#39;t worked</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="nodeStats.get_vector">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.get_vector">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_vector</span><span class="p">(</span><span class="n">coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">origin</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the normalised vector of the coordinate means in a branch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : npt.NDArray</span>
<span class="sd">            2xN array of x, y coordinates.</span>
<span class="sd">        origin : npt.NDArray</span>
<span class="sd">            2x1 array of an x, y coordinate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            Normalised vector from origin to the mean coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">origin</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vector</span> <span class="o">@</span> <span class="n">vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">vector</span> <span class="o">/</span> <span class="n">norm</span>  <span class="c1"># normalise vector so length=1</span></div>


<div class="viewcode-block" id="nodeStats.calc_angles">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.calc_angles">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_angles</span><span class="p">(</span><span class="n">vectors</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the angles between vectors in an array.</span>

<span class="sd">        Uses the formula:</span>

<span class="sd">        .. code-block:: RST</span>

<span class="sd">            cos(theta) = |a|•|b|/|a||b|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : npt.NDArray</span>
<span class="sd">            Array of 2x1 vectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            An array of the cosine of the angles between the vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">vectors</span> <span class="o">@</span> <span class="n">vectors</span><span class="o">.</span><span class="n">T</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dot</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="n">cos_angles</span> <span class="o">=</span> <span class="n">dot</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">cos_angles</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># ensures vector_x • vector_x angles are 0</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_angles</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">180</span><span class="p">)</span>  <span class="c1"># angles in degrees</span></div>


<div class="viewcode-block" id="nodeStats.pair_vectors">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.pair_vectors">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_vectors</span><span class="p">(</span><span class="n">vectors</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take a list of vectors and pairs them based on the angle between them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : npt.NDArray</span>
<span class="sd">            Array of 2x1 vectors to be paired.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            An array of the matching pair indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate cosine of angle</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
        <span class="c1"># match angles</span>
        <span class="k">return</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">best_matches</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats.best_matches">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.best_matches">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">best_matches</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">max_weight_matching</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turn a matrix into a graph and calculates the best matching index pairs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr : npt.NDArray</span>
<span class="sd">            Transpose symmetric MxM array where the value of index i, j represents a weight between i and j.</span>
<span class="sd">        max_weight_matching : bool</span>
<span class="sd">            Whether to obtain best matching pairs via maximum weight, or minimum weight matching.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            Array of pairs of indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_weight_matching</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">create_weighted_graph</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">matching</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">max_weight_matching</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">maxcardinality</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">create_weighted_graph</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">matching</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">min_weight_matching</span><span class="p">(</span><span class="n">G</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">matching</span></div>


<div class="viewcode-block" id="nodeStats.create_weighted_graph">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.create_weighted_graph">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_weighted_graph</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bipartite graph connecting i &lt;-&gt; j from a square matrix of weights matrix[i, j].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : npt.NDArray</span>
<span class="sd">            Square array of weights between rows and columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.Graph</span>
<span class="sd">            Bipatrite graph with edge weight i-&gt;j matching matrix[i,j].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="nodeStats.pair_angles">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.pair_angles">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_angles</span><span class="p">(</span><span class="n">angles</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pair angles that are 180 degrees to each other and removes them before selecting the next pair.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : npt.NDArray</span>
<span class="sd">             Square array (i,j) of angles between i and j.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">             A list of paired indexes in a list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angles_cp</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">angles_cp</span><span class="p">),</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>  <span class="c1"># add to list</span>
            <span class="n">angles_cp</span><span class="p">[[</span><span class="n">pair</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># set rows 0 to avoid picking again</span>
            <span class="n">angles_cp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">pair</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># set cols 0 to avoid picking again</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats.gaussian">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.gaussian">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mean</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the gaussian function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : npt.NDArray</span>
<span class="sd">            X values to be passed into the gaussian.</span>
<span class="sd">        h : float</span>
<span class="sd">            The peak height of the gaussian.</span>
<span class="sd">        mean : float</span>
<span class="sd">            The mean of the x values.</span>
<span class="sd">        sigma : float</span>
<span class="sd">            The standard deviation of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            The y-values of the gaussian performed on the x values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">h</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="nodeStats.interpolate_between_yvalue">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.interpolate_between_yvalue">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate_between_yvalue</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">yvalue</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the x value between the two points either side of yvalue in y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : npt.NDArray</span>
<span class="sd">            An array of length y.</span>
<span class="sd">        y : npt.NDArray</span>
<span class="sd">            An array of length x.</span>
<span class="sd">        yvalue : float</span>
<span class="sd">            A value within the bounds of the y array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The linearly interpolated x value between the arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yvalue</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yvalue</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>  <span class="c1"># if points cross through the hm value</span>
                <span class="k">return</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">lin_interp</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">yvalue</span><span class="o">=</span><span class="n">yvalue</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="nodeStats.calculate_fwhm">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.calculate_fwhm">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_fwhm</span><span class="p">(</span>
        <span class="n">heights</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">hm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the FWHM value.</span>

<span class="sd">        First identifyies the HM then finding the closest values in the distances array and using</span>
<span class="sd">        linear interpolation to calculate the FWHM.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        heights : npt.NDArray</span>
<span class="sd">            Array of heights.</span>
<span class="sd">        distances : npt.NDArray</span>
<span class="sd">            Array of distances.</span>
<span class="sd">        hm : Union[None, float], optional</span>
<span class="sd">            The halfmax value to match (if wanting the same HM between curves), by default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[float, list, list]</span>
<span class="sd">            The FWHM value, [distance at hm for 1st half of trace, distance at hm for 2nd half of trace,</span>
<span class="sd">            HM value], [index of the highest point, distance at highest point, height at highest point].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centre_fraction</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># in case zone approaches another node, look around centre for max</span>
        <span class="k">if</span> <span class="n">centre_fraction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">high_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="n">centre_fraction</span><span class="p">:</span><span class="o">-</span><span class="n">centre_fraction</span><span class="p">])</span> <span class="o">+</span> <span class="n">centre_fraction</span>
        <span class="c1"># get array halves to find first points that cross hm</span>
        <span class="n">arr1</span> <span class="o">=</span> <span class="n">heights</span><span class="p">[:</span><span class="n">high_idx</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dist1</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:</span><span class="n">high_idx</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="n">heights</span><span class="p">[</span><span class="n">high_idx</span><span class="p">:]</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">high_idx</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">hm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get half max</span>
            <span class="n">hm</span> <span class="o">=</span> <span class="p">(</span><span class="n">heights</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">heights</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">heights</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="c1"># half max value -&gt; try to make it the same as other crossing branch?</span>
            <span class="c1"># increase make hm = lowest of peak if it doesn’t hit one side</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hm</span><span class="p">:</span>
                <span class="n">arr1_local_min</span> <span class="o">=</span> <span class="n">argrelextrema</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># closest to end</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hm</span> <span class="o">=</span> <span class="n">arr1</span><span class="p">[</span><span class="n">arr1_local_min</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># index error when no local minima</span>
                    <span class="n">hm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hm</span><span class="p">:</span>
                <span class="n">arr2_local_min</span> <span class="o">=</span> <span class="n">argrelextrema</span><span class="p">(</span><span class="n">arr2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># closest to start</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hm</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">arr2_local_min</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># index error when no local minima</span>
                    <span class="n">hm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span>
        <span class="n">arr1_hm</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">interpolate_between_yvalue</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">dist1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">arr1</span><span class="p">,</span> <span class="n">yvalue</span><span class="o">=</span><span class="n">hm</span><span class="p">)</span>
        <span class="n">arr2_hm</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">interpolate_between_yvalue</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">dist2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">arr2</span><span class="p">,</span> <span class="n">yvalue</span><span class="o">=</span><span class="n">hm</span><span class="p">)</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">arr2_hm</span> <span class="o">-</span> <span class="n">arr1_hm</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;fwhm&quot;</span><span class="p">:</span> <span class="n">fwhm</span><span class="p">,</span>
            <span class="s2">&quot;half_maxs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">arr1_hm</span><span class="p">,</span> <span class="n">arr2_hm</span><span class="p">,</span> <span class="n">hm</span><span class="p">],</span>
            <span class="s2">&quot;peaks&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">high_idx</span><span class="p">,</span> <span class="n">distances</span><span class="p">[</span><span class="n">high_idx</span><span class="p">],</span> <span class="n">heights</span><span class="p">[</span><span class="n">high_idx</span><span class="p">]],</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="nodeStats.lin_interp">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.lin_interp">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lin_interp</span><span class="p">(</span><span class="n">point_1</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">point_2</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">xvalue</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">yvalue</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Linear interp 2 points by finding line equation and subbing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point_1 : list</span>
<span class="sd">            List of an x and y coordinate.</span>
<span class="sd">        point_2 : list</span>
<span class="sd">            List of an x and y coordinate.</span>
<span class="sd">        xvalue : Union[float, None], optional</span>
<span class="sd">            Value at which to interpolate to get a y coordinate, by default None.</span>
<span class="sd">        yvalue : Union[float, None], optional</span>
<span class="sd">            Value at which to interpolate to get an x coordinate, by default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Value of x or y linear interpolation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">point_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">point_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">point_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">xvalue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">xvalue</span> <span class="o">+</span> <span class="n">c</span>  <span class="c1"># interp_y</span>
        <span class="k">if</span> <span class="n">yvalue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">yvalue</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>  <span class="c1"># interp_x</span>
        <span class="k">raise</span> <span class="ne">ValueError</span></div>


<div class="viewcode-block" id="nodeStats.order_branches">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.order_branches">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">order_branches</span><span class="p">(</span><span class="n">branch1</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">branch2</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Order the two ordered arrays based on the closest endpoint coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        branch1 : npt.NDArray</span>
<span class="sd">            An Nx2 array describing coordinates.</span>
<span class="sd">        branch2 : npt.NDArray</span>
<span class="sd">            An Nx2 array describing coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            An tuple with the each coordinate array ordered to follow on from one-another.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endpoints1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">branch1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">branch1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">endpoints2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">branch2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">branch2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">sum1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">endpoints1</span> <span class="o">-</span> <span class="n">endpoints2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sum2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">endpoints1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">endpoints2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sum1</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">sum2</span><span class="o">.</span><span class="n">min</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sum1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">branch1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">branch2</span>
            <span class="k">return</span> <span class="n">branch1</span><span class="p">,</span> <span class="n">branch2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sum2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">branch1</span><span class="p">,</span> <span class="n">branch2</span>
        <span class="k">return</span> <span class="n">branch1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">branch2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="nodeStats.binary_line">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.binary_line">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">binary_line</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a binary path following the straight line between 2 points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : npt.NDArray</span>
<span class="sd">            A coordinate.</span>
<span class="sd">        end : npt.NDArray</span>
<span class="sd">            Another coordinate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            An Nx2 coordinate array that the line passes through.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">m_swap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">x_swap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">slope</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># swap x and y if slope will cause skips</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">end</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">slope</span>
            <span class="n">m_swap</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># swap x coords if coords wrong way around</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>
            <span class="n">x_swap</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># code assumes slope &lt; 1 hence swap</span>
        <span class="n">x_start</span><span class="p">,</span> <span class="n">y_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">x_end</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">y_true</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">y_start</span>
            <span class="n">y_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_true</span><span class="p">)</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y_pixel</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">m_swap</span><span class="p">:</span>  <span class="c1"># if swapped due to slope, return</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x_swap</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_swap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arr</span></div>


<div class="viewcode-block" id="nodeStats.coord_dist_rad">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.coord_dist_rad">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coord_dist_rad</span><span class="p">(</span><span class="n">coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">centre</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">pixel_to_nm_scaling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the distance from the centre coordinate to a point along the ordered coordinates.</span>

<span class="sd">        This differs to traversal along the coordinates taken. This also averages any common distance</span>
<span class="sd">        values and makes those in the trace before the node index negative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : npt.NDArray</span>
<span class="sd">            Nx2 array of branch coordinates.</span>
<span class="sd">        centre : npt.NDArray</span>
<span class="sd">            A 1x2 array of the centre coordinates to identify a 0 point for the node.</span>
<span class="sd">        pixel_to_nm_scaling : float, optional</span>
<span class="sd">            The pixel to nanometer scaling factor to provide real units, by default 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            A Nx1 array of the distance from the node centre.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff_coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">-</span> <span class="n">centre</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">coords</span> <span class="o">==</span> <span class="n">centre</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if centre not in coords, reassign centre</span>
            <span class="n">diff_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">centre</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">diff_dists</span><span class="p">)]</span>
        <span class="n">cross_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">coords</span> <span class="o">==</span> <span class="n">centre</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">rad_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">diff_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">rad_dist</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">cross_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">rad_dist</span> <span class="o">*</span> <span class="n">pixel_to_nm_scaling</span></div>


<div class="viewcode-block" id="nodeStats.above_below_value_idx">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.above_below_value_idx">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">above_below_value_idx</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify indices of the array neighbouring the specified value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : npt.NDArray</span>
<span class="sd">            Array of values.</span>
<span class="sd">        value : float</span>
<span class="sd">            Value to identify indices between.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of the lower index and higher index around the value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            When the value is in the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">idx1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">array</span><span class="p">[</span><span class="n">idx1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">idx1</span><span class="p">]:</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span>  <span class="c1"># this will be if the number is the same</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">indices</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="nodeStats.average_height_trace">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.average_height_trace">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_height_trace</span><span class="p">(</span>  <span class="c1"># noqa: C901</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">branch_mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">branch_coords</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">centre</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Average two side-by-side ordered skeleton distance and height traces.</span>

<span class="sd">        Dilate the original branch to create two additional side-by-side branches</span>
<span class="sd">        in order to get a more accurate average of the height traces. This function produces</span>
<span class="sd">        the common distances between these 3 branches, and their averaged heights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img : npt.NDArray</span>
<span class="sd">            An array of numbers pertaining to an image.</span>
<span class="sd">        branch_mask : npt.NDArray</span>
<span class="sd">            A binary array of the branch, must share the same dimensions as the image.</span>
<span class="sd">        branch_coords : npt.NDArray</span>
<span class="sd">            Ordered coordinates of the branch mask.</span>
<span class="sd">        centre : Union[float, None]</span>
<span class="sd">            The coordinates to centre the branch around.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple of the averaged heights from the linetrace and their corresponding distances</span>
<span class="sd">            from the crossing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get heights and dists of the original (middle) branch</span>
        <span class="n">branch_dist</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">coord_dist_rad</span><span class="p">(</span><span class="n">branch_coords</span><span class="p">,</span> <span class="n">centre</span><span class="p">)</span>
        <span class="c1"># branch_dist = self.coord_dist(branch_coords)</span>
        <span class="n">branch_heights</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="n">branch_dist</span><span class="p">,</span> <span class="n">branch_heights</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">average_uniques</span><span class="p">(</span>
            <span class="n">branch_dist</span><span class="p">,</span> <span class="n">branch_heights</span>
        <span class="p">)</span>  <span class="c1"># needs to be paired with coord_dist_rad</span>
        <span class="n">dist_zero_point</span> <span class="o">=</span> <span class="n">branch_dist</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">centre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">branch_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">centre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">branch_dist_norm</span> <span class="o">=</span> <span class="n">branch_dist</span> <span class="o">-</span> <span class="n">dist_zero_point</span>  <span class="c1"># - 0  # branch_dist[branch_heights.argmax()]</span>

        <span class="c1"># want to get a 3 pixel line trace, one on each side of orig</span>
        <span class="n">dilate</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">branch_mask</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dilate</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">dilate</span><span class="p">)</span>
        <span class="n">dilate_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dilate</span> <span class="o">!=</span> <span class="n">branch_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dilate2</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">dilate</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dilate2</span><span class="p">[(</span><span class="n">dilate</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">branch_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">dilate2</span><span class="p">)</span>
        <span class="c1"># Cleanup stages - re-entering, early terminating, closer traces</span>
        <span class="c1">#   if parallel trace out and back in zone, can get &gt; 2 labels</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">_remove_re_entering_branches</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">remaining_branches</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1">#   if parallel trace doesn&#39;t exit window, can get 1 label</span>
        <span class="c1">#       occurs when skeleton has poor connections (extra branches which cut corners)</span>
        <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">convolve_skeleton</span><span class="p">(</span><span class="n">branch_mask</span><span class="p">)</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">conv</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">endpoint</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>  <span class="c1"># may be &gt;1 endpoint</span>
                <span class="n">para_trace_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">abs_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">para_trace_coords</span> <span class="o">-</span> <span class="n">endpoint</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">min_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">abs_diff</span> <span class="o">==</span> <span class="n">abs_diff</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                <span class="n">trace_coords_remove</span> <span class="o">=</span> <span class="n">para_trace_coords</span><span class="p">[</span><span class="n">min_idxs</span><span class="p">]</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">trace_coords_remove</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">trace_coords_remove</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c1">#   reduce binary dilation distance</span>
        <span class="n">parallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">branch_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">single</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">single</span><span class="p">[</span><span class="n">single</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">single</span><span class="p">[</span><span class="n">single</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sing_dil</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">single</span><span class="p">)</span>
            <span class="n">parallel</span><span class="p">[(</span><span class="n">sing_dil</span> <span class="o">==</span> <span class="n">dilate_minus</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sing_dil</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">binary</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">binary</span><span class="p">[</span><span class="n">binary</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">binary</span> <span class="o">+=</span> <span class="n">branch_mask</span>

        <span class="c1"># get and order coords, then get heights and distances relitive to node centre / highest point</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">trace_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">trace_img</span> <span class="o">=</span> <span class="n">getSkeleton</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">trace_img</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;zhang&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">()</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">order_branch</span><span class="p">(</span><span class="n">trace_img</span><span class="p">,</span> <span class="n">branch_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">height_trace</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">trace</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">trace</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">coord_dist_rad</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">centre</span><span class="p">)</span>  <span class="c1"># self.coord_dist(trace)</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">height_trace</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">average_uniques</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">height_trace</span><span class="p">)</span>  <span class="c1"># needs to be paired with coord_dist_rad</span>
            <span class="n">heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">height_trace</span><span class="p">)</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">dist</span> <span class="o">-</span> <span class="n">dist_zero_point</span>  <span class="c1"># - 0</span>
            <span class="p">)</span>  <span class="c1"># branch_dist[branch_heights.argmax()]) #dist[central_heights.argmax()])</span>
        <span class="c1"># Make like coord system using original branch</span>
        <span class="n">avg1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">avg2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mid_dist</span> <span class="ow">in</span> <span class="n">branch_dist_norm</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">heights</span><span class="p">)):</span>
                <span class="c1"># check if distance already in traces array</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mid_dist</span> <span class="o">==</span> <span class="n">distance</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mid_dist</span> <span class="o">==</span> <span class="n">distance</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">avg1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mid_dist</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">avg2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mid_dist</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
                <span class="c1"># if not, linearly interpolate the mid-branch value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># get index after and before the mid branches&#39; x coord</span>
                    <span class="n">xidxs</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">above_below_value_idx</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">xidxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">pass</span>  <span class="c1"># if indexes outside of range, pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">point1</span> <span class="o">=</span> <span class="p">[</span><span class="n">distance</span><span class="p">[</span><span class="n">xidxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">height</span><span class="p">[</span><span class="n">xidxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
                        <span class="n">point2</span> <span class="o">=</span> <span class="p">[</span><span class="n">distance</span><span class="p">[</span><span class="n">xidxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">height</span><span class="p">[</span><span class="n">xidxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="o">.</span><span class="n">lin_interp</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">xvalue</span><span class="o">=</span><span class="n">mid_dist</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">avg1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mid_dist</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">avg2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mid_dist</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
        <span class="n">avg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">avg1</span><span class="p">)</span>
        <span class="n">avg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">avg2</span><span class="p">)</span>
        <span class="c1"># ensure arrays are same length to average</span>
        <span class="n">temp_x</span> <span class="o">=</span> <span class="n">branch_dist_norm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">branch_dist_norm</span><span class="p">,</span> <span class="n">avg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])]</span>
        <span class="n">common_dists</span> <span class="o">=</span> <span class="n">avg2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">avg2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">temp_x</span><span class="p">)]</span>

        <span class="n">common_avg_branch_heights</span> <span class="o">=</span> <span class="n">branch_heights</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">branch_dist_norm</span><span class="p">,</span> <span class="n">common_dists</span><span class="p">)]</span>
        <span class="n">common_avg1_heights</span> <span class="o">=</span> <span class="n">avg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">avg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">common_dists</span><span class="p">)]</span>
        <span class="n">common_avg2_heights</span> <span class="o">=</span> <span class="n">avg2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">avg2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">common_dists</span><span class="p">)]</span>

        <span class="n">average_heights</span> <span class="o">=</span> <span class="p">(</span><span class="n">common_avg_branch_heights</span> <span class="o">+</span> <span class="n">common_avg1_heights</span> <span class="o">+</span> <span class="n">common_avg2_heights</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">common_dists</span><span class="p">,</span>
            <span class="n">average_heights</span><span class="p">,</span>
            <span class="n">binary</span><span class="p">,</span>
            <span class="p">[[</span><span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">branch_heights</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">branch_dist_norm</span><span class="p">,</span> <span class="n">distances</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats.fill_holes">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.fill_holes">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fill_holes</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill all holes within a binary mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : npt.NDArray</span>
<span class="sd">            Binary array of object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            Binary array of object with any interior holes filled in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inv_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">lbl_inv</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">inv_mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idxs</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lbl_inv</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lbl_inv</span> <span class="o">!=</span> <span class="n">max_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodeStats._remove_re_entering_branches">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats._remove_re_entering_branches">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_re_entering_branches</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">remaining_branches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove smallest branches which branches exit and re-enter the viewing area.</span>

<span class="sd">        Contninues until only &lt;remaining_branches&gt; remain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : npt.NDArray</span>
<span class="sd">            Skeletonised binary mask of an object.</span>
<span class="sd">        remaining_branches : int, optional</span>
<span class="sd">            Number of objects (branches) to keep, by default 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray</span>
<span class="sd">            Mask with only a single skeletonised branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rtn_image</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">binary_image</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">binary_image</span><span class="p">[</span><span class="n">binary_image</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">binary_image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">remaining_branches</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">remaining_branches</span><span class="p">:</span>
                <span class="n">smallest_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">lens</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rtn_image</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">smallest_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">lens</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lens</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">rtn_image</span></div>


<div class="viewcode-block" id="nodeStats.only_centre_branches">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.only_centre_branches">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">only_centre_branches</span><span class="p">(</span><span class="n">node_image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">node_coordinate</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all branches not connected to the current node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_image : npt.NDArray</span>
<span class="sd">            An image of the skeletonised area surrounding the node where</span>
<span class="sd">            the background = 0, skeleton = 1, termini = 2, nodes = 3.</span>
<span class="sd">        node_coordinate : npt.NDArray</span>
<span class="sd">            2x1 coordinate describing the position of a node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npt.NDArray[np.int32]</span>
<span class="sd">            The initial node image but only with skeletal branches</span>
<span class="sd">            connected to the middle node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_image_cp</span> <span class="o">=</span> <span class="n">node_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># get node-only image</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">node_image_cp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">labeled_nodes</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># find which cluster is closest to the centre</span>
        <span class="n">node_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">nodes</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">min_coords</span> <span class="o">=</span> <span class="n">node_coords</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">node_coords</span> <span class="o">-</span> <span class="n">node_coordinate</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
        <span class="n">centre_idx</span> <span class="o">=</span> <span class="n">labeled_nodes</span><span class="p">[</span><span class="n">min_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># get nodeless image</span>
        <span class="n">nodeless</span> <span class="o">=</span> <span class="n">node_image_cp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nodeless</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="p">(</span><span class="n">node_image</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">node_image</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># if termini, need this in the labeled branches too</span>
        <span class="n">nodeless</span><span class="p">[</span><span class="n">labeled_nodes</span> <span class="o">==</span> <span class="n">centre_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># return centre node</span>
        <span class="n">labeled_nodeless</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">nodeless</span><span class="p">)</span>

        <span class="c1"># apply to return image</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">labeled_nodeless</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node_image_cp</span><span class="p">[</span><span class="n">labeled_nodeless</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">node_image_cp</span><span class="p">[</span><span class="n">labeled_nodeless</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>

        <span class="c1"># remove small area around other nodes</span>
        <span class="n">labeled_nodes</span><span class="p">[</span><span class="n">labeled_nodes</span> <span class="o">==</span> <span class="n">centre_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">non_central_node_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">labeled_nodes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">non_central_node_coords</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">coord_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">coord_val</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">coord</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">coord_val</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">node_image_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">coord</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_image_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">node_image_cp</span><span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">node_image_cp</span></div>


<div class="viewcode-block" id="nodeStats.average_uniques">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.average_uniques">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_uniques</span><span class="p">(</span><span class="n">arr1</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">arr2</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain the unique values of both arrays, and the average of common values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr1 : npt.NDArray</span>
<span class="sd">            An array.</span>
<span class="sd">        arr2 : npt.NDArray</span>
<span class="sd">            An array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The unique values of both arrays, and the averaged common values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr1_uniq</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">arr2_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">arr1_uniq</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr1</span><span class="p">[</span><span class="n">index</span><span class="p">]):</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">arr1</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">arr2_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mean</span>

        <span class="k">return</span> <span class="n">arr1</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">arr2_new</span></div>


<div class="viewcode-block" id="nodeStats.average_crossing_confs">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.average_crossing_confs">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_crossing_confs</span><span class="p">(</span><span class="n">node_dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the average crossing confidence of all crossings in the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_dict : dict</span>
<span class="sd">            A dictionary containing node statistics and information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[None, float]</span>
<span class="sd">            The value of minimum confidence or none if not possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_conf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">valid_confs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sum_conf</span> <span class="o">+=</span> <span class="n">confidence</span>
                <span class="n">valid_confs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sum_conf</span> <span class="o">/</span> <span class="n">valid_confs</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="nodeStats.minimum_crossing_confs">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.minimum_crossing_confs">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">minimum_crossing_confs</span><span class="p">(</span><span class="n">node_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum crossing confidence of all crossings in the molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_dict : dict</span>
<span class="sd">            A dictionary containing node statistics and information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[None, float]</span>
<span class="sd">            The value of minimum confidence or none if not possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">confidences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valid_confs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">confidence</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;confidence&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">confidence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">confidences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">confidence</span><span class="p">)</span>
                <span class="n">valid_confs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">confidences</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="nodeStats.compile_metrics">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodeStats.compile_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compile_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the number of crossings, average and minimum crossing confidence to the metrics dictionary.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;num_crossings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">node_centre_mask</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;avg_crossing_confidence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">nodeStats</span><span class="o">.</span><span class="n">average_crossing_confs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dicts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;min_crossing_confidence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">nodeStats</span><span class="o">.</span><span class="n">minimum_crossing_confs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_dicts</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="nodestats_image">
<a class="viewcode-back" href="../../../autoapi/topostats/tracing/nodestats/index.html#topostats.tracing.nodestats.nodestats_image">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">nodestats_image</span><span class="p">(</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
    <span class="n">disordered_tracing_direction_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">pixel_to_nm_scaling</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">node_joining_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">node_extend_dist</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">branch_pairing_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">pair_odd_branches</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialise the nodeStats class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : npt.NDArray</span>
<span class="sd">        The array of pixels.</span>
<span class="sd">    disordered_tracing_direction_data : dict</span>
<span class="sd">        The images and bbox coordinates of the pruned skeletons.</span>
<span class="sd">    filename : str</span>
<span class="sd">        The name of the file being processed. For logging purposes.</span>
<span class="sd">    pixel_to_nm_scaling : float</span>
<span class="sd">        The pixel to nm scaling factor.</span>
<span class="sd">    node_joining_length : float</span>
<span class="sd">        The length over which to join skeletal intersections to be counted as one crossing.</span>
<span class="sd">    node_joining_length : float</span>
<span class="sd">        The distance over which to join nearby odd-branched nodes.</span>
<span class="sd">    node_extend_dist : float</span>
<span class="sd">        The distance under which to join odd-branched node regions.</span>
<span class="sd">    branch_pairing_length : float</span>
<span class="sd">        The length from the crossing point to pair and trace, obtaining FWHM&#39;s.</span>
<span class="sd">    pair_odd_branches : bool</span>
<span class="sd">        Whether to try and pair odd-branched nodes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[dict, pd.DataFrame, dict, dict]</span>
<span class="sd">        The nodestats statistics for each crossing, crossing statistics to be added to the grain statistics,</span>
<span class="sd">        an image dictionary of nodestats steps for the entire image, and single grain images.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_grains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">disordered_tracing_direction_data</span><span class="p">)</span>
    <span class="n">img_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">nodestats_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Images for diagnostics edited during processing</span>
    <span class="n">all_images</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;convolved_skeletons&quot;</span><span class="p">:</span> <span class="n">img_base</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="s2">&quot;node_centres&quot;</span><span class="p">:</span> <span class="n">img_base</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="s2">&quot;connected_nodes&quot;</span><span class="p">:</span> <span class="n">img_base</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
    <span class="p">}</span>
    <span class="n">nodestats_branch_images</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">grainstats_additions</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Calculating NodeStats statistics for </span><span class="si">{</span><span class="n">n_grains</span><span class="si">}</span><span class="s2"> grains...&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n_grain</span><span class="p">,</span> <span class="n">disordered_tracing_grain_data</span> <span class="ow">in</span> <span class="n">disordered_tracing_direction_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">nodestats</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># reset the nodestats variable</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nodestats</span> <span class="o">=</span> <span class="n">nodeStats</span><span class="p">(</span>
                <span class="n">image</span><span class="o">=</span><span class="n">disordered_tracing_grain_data</span><span class="p">[</span><span class="s2">&quot;original_image&quot;</span><span class="p">],</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">disordered_tracing_grain_data</span><span class="p">[</span><span class="s2">&quot;original_grain&quot;</span><span class="p">],</span>
                <span class="n">smoothed_mask</span><span class="o">=</span><span class="n">disordered_tracing_grain_data</span><span class="p">[</span><span class="s2">&quot;smoothed_grain&quot;</span><span class="p">],</span>
                <span class="n">skeleton</span><span class="o">=</span><span class="n">disordered_tracing_grain_data</span><span class="p">[</span><span class="s2">&quot;pruned_skeleton&quot;</span><span class="p">],</span>
                <span class="n">pixel_to_nm_scaling</span><span class="o">=</span><span class="n">pixel_to_nm_scaling</span><span class="p">,</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">n_grain</span><span class="o">=</span><span class="n">n_grain</span><span class="p">,</span>
                <span class="n">node_joining_length</span><span class="o">=</span><span class="n">node_joining_length</span><span class="p">,</span>
                <span class="n">node_extend_dist</span><span class="o">=</span><span class="n">node_extend_dist</span><span class="p">,</span>
                <span class="n">branch_pairing_length</span><span class="o">=</span><span class="n">branch_pairing_length</span><span class="p">,</span>
                <span class="n">pair_odd_branches</span><span class="o">=</span><span class="n">pair_odd_branches</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">nodestats_dict</span><span class="p">,</span> <span class="n">node_image_dict</span> <span class="o">=</span> <span class="n">nodestats</span><span class="o">.</span><span class="n">get_node_stats</span><span class="p">()</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Nodestats processed </span><span class="si">{</span><span class="n">n_grain</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">n_grains</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># compile images</span>
            <span class="n">nodestats_images</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;convolved_skeletons&quot;</span><span class="p">:</span> <span class="n">nodestats</span><span class="o">.</span><span class="n">conv_skelly</span><span class="p">,</span>
                <span class="s2">&quot;node_centres&quot;</span><span class="p">:</span> <span class="n">nodestats</span><span class="o">.</span><span class="n">node_centre_mask</span><span class="p">,</span>
                <span class="s2">&quot;connected_nodes&quot;</span><span class="p">:</span> <span class="n">nodestats</span><span class="o">.</span><span class="n">connected_nodes</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">nodestats_branch_images</span><span class="p">[</span><span class="n">n_grain</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_image_dict</span>

            <span class="c1"># compile metrics</span>
            <span class="n">grainstats_additions</span><span class="p">[</span><span class="n">n_grain</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">filename</span><span class="p">,</span>
                <span class="s2">&quot;grain_number&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_grain</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">}</span>
            <span class="n">grainstats_additions</span><span class="p">[</span><span class="n">n_grain</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nodestats</span><span class="o">.</span><span class="n">metrics</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nodestats_dict</span><span class="p">:</span>  <span class="c1"># if the grain&#39;s nodestats dict is not empty</span>
                <span class="n">nodestats_data</span><span class="p">[</span><span class="n">n_grain</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodestats_dict</span>

            <span class="c1"># remap the cropped images back onto the original</span>
            <span class="k">for</span> <span class="n">image_name</span><span class="p">,</span> <span class="n">full_image</span> <span class="ow">in</span> <span class="n">all_images</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">crop</span> <span class="o">=</span> <span class="n">nodestats_images</span><span class="p">[</span><span class="n">image_name</span><span class="p">]</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="n">disordered_tracing_grain_data</span><span class="p">[</span><span class="s2">&quot;bbox&quot;</span><span class="p">]</span>
                <span class="n">full_image</span><span class="p">[</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">crop</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-exception-caught</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">] : Nodestats for </span><span class="si">{</span><span class="n">n_grain</span><span class="si">}</span><span class="s2"> failed. Consider raising an issue on GitHub. Error: &quot;</span><span class="p">,</span>
                <span class="n">exc_info</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">nodestats_data</span><span class="p">[</span><span class="n">n_grain</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># turn the grainstats additions into a dataframe, # might need to do something for when everything is empty</span>
        <span class="n">grainstats_additions_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">grainstats_additions</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nodestats_data</span><span class="p">,</span> <span class="n">grainstats_additions_df</span><span class="p">,</span> <span class="n">all_images</span><span class="p">,</span> <span class="n">nodestats_branch_images</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2023, TopoStats authors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>